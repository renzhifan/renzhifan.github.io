(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{587:function(e,s,a){"use strict";a.r(s);var t=a(33),r=Object(t.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"aof-日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-日志"}},[e._v("#")]),e._v(" AOF 日志")]),e._v(" "),a("h3",{attrs:{id:"写后日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写后日志"}},[e._v("#")]),e._v(" 写后日志")]),e._v(" "),a("blockquote",[a("p",[e._v("AOF 的全称是 Append Only File，它是一种增量备份日志，不过与 MySQL 先写日志、再写磁盘的写前日志（Write-Ahead Logging，简称 WAL）相反，AOF 是写后日志，即先执行命令、再写入内存、最后记录到日志。")])]),e._v(" "),a("blockquote",[a("p",[e._v("为什么要这么做呢？因为 Redis 为了提高性能，节省不必要的系统开销，在记录 AOF 日志的时候，并不会检查客户端请求的指令语法是否正确，如果先记日志再执行的话，可能会记录语法错误的指令，从而导致恢复数据时出错")])]),e._v(" "),a("blockquote",[a("p",[e._v("通过写后日志，指令执行成功后才会记录到 AOF 日志，否则就会给客户端报错，要求传递正确的 Redis 指令，这样就不会导致 AOF 日志记录错误的指令了。另外，这样做的另一个潜在好处是不会阻塞 Redis 写操作。")])]),e._v(" "),a("h3",{attrs:{id:"回写策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回写策略"}},[e._v("#")]),e._v(" 回写策略")]),e._v(" "),a("blockquote",[a("p",[e._v("但是这样一来，就会带来我们在 MySQL 中多次提到的隐患 —— 如果 Redis 指令执行成功，在日志还没有记录到 AOF 日志之前 Redis 服务/系统崩溃，重启后就会导致无法恢复最新数据")])]),e._v(" "),a("blockquote",[a("p",[e._v("另外，记录 AOF 日志也是在 Redis 主线程中进行的，AOF 日志的写入虽然不会阻塞当前指令的写操作，但是会阻塞下一个指令的写操作啊，为了解决这两个问题，我们就要合理控制 AOF 日志写入磁盘的时机。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Redis 为 AOF 日志专门提供了一个配置项 "),a("code",[e._v("appendfsync")]),e._v("，用于配置 AOF 日志写入磁盘的时机：")])]),e._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync always")]),e._v("\nappendfsync everysec\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync no")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("我们来看看每个配置值的含义和优缺点:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("always")]),e._v("：同步写入 —— 每个 Redis 写命令执行完，立即将日志写入磁盘，这种策略可以做到数据基本不丢失（数据最安全），但是过于频繁地操作磁盘显然会影响 Redis 主线程性能（性能最差）")]),e._v(" "),a("li",[a("code",[e._v("everysec")]),e._v("：每秒写入 —— 每个 Redis 写命令执行完，先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘，这种策略既可以将数据丢失的风险降低（1s内可更新数据能会丢失），又可以避免同步写入磁盘对 Redis 性能的影响，是一种兼顾性能和数据安全的折中方案")]),e._v(" "),a("li",[a("code",[e._v("no")]),e._v("操作系统控制写入时机 —— 每个 Redis 写命令执行完，先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写入磁盘，这种策略下性能是最好的，但控制权已经不在 Redis 手中了，只要日志没有写入磁盘，则数据全部丢失，完全不可控（数据最不安全）")])]),e._v(" "),a("p",[e._v("因此，在 "),a("code",[e._v("redis.conf")]),e._v(" 配置文件中，默认使用的是 "),a("code",[e._v("everysec")]),e._v("，即每秒写入策略，它是一种折中方案，是综合来看最好的选择，建议生产环境使用这个配置值")]),e._v(" "),a("blockquote",[a("p",[e._v("AOF 日志写入磁盘操作通过调用操作系统提供的 "),a("code",[e._v("fsync")]),e._v(" 函数完成，这是一个耗时的磁盘 IO 操作")])]),e._v(" "),a("h3",{attrs:{id:"aof-重写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写"}},[e._v("#")]),e._v(" AOF 重写")]),e._v(" "),a("blockquote",[a("p",[e._v("不管使用那种回写策略，随着系统的运行，AOF 作为增量日志，都会越来越臃肿和庞大，这将为 Redis 服务重启通过 AOF 日志恢复数据带来隐患，为此，Redis 提供了 "),a("code",[e._v("bgrewriteaof")]),e._v(" 指令用于对 AOF 日志进行瘦身")])]),e._v(" "),a("blockquote",[a("p",[e._v("瘦身原理很简单，就是"),a("code",[e._v("将每个键的多个操作指令合并为一条")]),e._v("（以最后更新的值为准）。具体实现是执行 "),a("code",[e._v("bgrewriteaof")]),e._v(" 指令时，会 fork 出一个子线程，异步遍历 Redis 数据库所有键，并将其转化为一系列 Redis 操作指令（比如键值对 testkey:testvalue 会生成 set testkey testvalue 指令），存放到一个新的 AOF 日志，存放完成后，再将这个过程中产生的 AOF 增量日志追加到这个新的 AOF 日志，最后再用新的 AOF 日志替代老的，AOF 瘦身工作就完成了。")])]),e._v(" "),a("blockquote",[a("p",[e._v("之所以 fork 一个新的子线程进行 AOF 重写，是为了避免阻塞 Redis 主线程，造成性能下降（Redis 性能优先，处处透露着这种提升性能的思想）。这个子线程在 fork 的时候，会将当前主线程的数据拷贝过来，然后在不影响主线程处理客户端请求的情况下，遍历这些拷贝过来的 Redis 数据副本进行 AOF 重写，这个时候，主线程也会产生新的 AOF 增量日志，当子线程完成数据副本的 AOF 重写后，还要将这些新增的 AOF 日志追加过来，才能形成最新的 AOF 日志")])]),e._v(" "),a("p",[e._v("整个过程如下所示：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20210325170553.jpeg",alt:""}})]),e._v(" "),a("p",[e._v("有两个配置可以控制aof自动重写的频率：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("auto-aof-rewrite-min-size 64mb： aof文件至少要达到64m才会触发制动重写，文件太小恢复速度本来就很快，重写的意义不大\n\nauto-aof-rewrite-percentage 100：aof文件上一次重写后文件大小增长了100%则再次触发重写\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("ul",[a("li",[e._v("当然aof还可以手动重写，进入redis客户端执行命令bgrewriteaof重写aof。")]),e._v(" "),a("li",[e._v("触发aof重写时，redis会fork一个子进程去做，不会对redis正常命令处理有太多影响。")])]),e._v(" "),a("h2",{attrs:{id:"rdb-快照"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb-快照"}},[e._v("#")]),e._v(" RDB 快照")]),e._v(" "),a("blockquote",[a("p",[e._v("RDB 是 Redis DataBase 的简写，所以 RDB 快照也就是 Redis 数据库快照，和 AOF 日志不同，它是系统某个时刻 Redis 数据库全量数据的快照，这意味着执行一次 RDB 快照需要遍历所有 Redis 键值对，然后持久化到磁盘，这两者都是耗时操作，因此，就不能在 Redis 主线程中进行 RDB 快照，否则会阻塞主线程，让 Redis 的高性能英名毁于一旦")])]),e._v(" "),a("h3",{attrs:{id:"写时复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#写时复制"}},[e._v("#")]),e._v(" 写时复制")]),e._v(" "),a("blockquote",[a("p",[e._v("为了保证高性能，Redis 采用了一种名为写时复制（Copy On Write，简称 COW）的多进程机制实现 RDB 快照。")])]),e._v(" "),a("blockquote",[a("p",[e._v("具体说来，当需要进行 RDB 快照时，Redis 主进程会 fork 一个子进程出来，子进程会共享父进程 fork 时刻的内存数据，这就是要快照持久化的数据了，接下来，RDB 快照将在独立的子进程中进行，在此期间，Redis 主进程可以像之前一样正常处理客户端请求和响应，不会阻塞")])]),e._v(" "),a("blockquote",[a("p",[e._v("子进程在 RDB 快照期间，只会读取共享的 Redis 内存数据，然后将其持久化到磁盘，但是主（父）进程是在不断处理客户端请求的，这里面有读取指令，也有更新、删除指令，那这些更新操作会不会影响到 RDB 快照呢？")])]),e._v(" "),a("p",[e._v("答案是不会。因为当有更新操作时，Redis 底层会通过操作系统的写时复制机制将这块数据复制一份分离出来，然后主进程直接修改原来的数据，子进程则会读取副本数据进行持久化，因此子进程对应的数据块是没有变化的，还是子进程 fork 时那一瞬间的数据，仿佛那一刻真的被按下快门，永久定格下来。")]),e._v(" "),a("p",[e._v("整个过程图示如下：")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20210325170941.jpeg",alt:""}})]),e._v(" "),a("blockquote",[a("p",[e._v("当然，你也不需要担心这个写时复制会导致系统内存紧张，因为撑死了也不会超过原来 Redis 内存的 2 倍，何况 Redis 数据库中还有很多冷数据，但是我们在配置 Redis 内存上限时还是要考虑这些问题，留有余地，避免出现内存资源耗尽，Redis 服务不可用")])]),e._v(" "),a("h3",{attrs:{id:"快照时机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#快照时机"}},[e._v("#")]),e._v(" 快照时机")]),e._v(" "),a("p",[e._v("我们可以通过 Redis 配置文件 redis.conf 的 save 配置项进行配置，默认配置如下：")]),e._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[e._v("save "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("900")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v("\nsave "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("300")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),e._v("\nsave "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("60")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10000")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br")])]),a("p",[e._v("对应的含义是：")]),e._v(" "),a("ul",[a("li",[e._v("如果 900 秒（15 分钟）内至少有 1 个键修改，则执行一次 RDB 快照；")]),e._v(" "),a("li",[e._v("如果 300 秒（5 分钟）内至少有 10 个键修改，则执行一次 RDB 快照；")]),e._v(" "),a("li",[e._v("如果 60 秒（1 分钟）内至少有 10000 个键修改，则执行一次 RDB 快照。")])]),e._v(" "),a("p",[e._v("这是服务端自动执行 RDB 快照的机制，除此之外，你还可以通过 Redis 客户端发送如下指令主动进行 RDB 快照持久化：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("save")]),e._v("：在 Redis 主线程同步进行 RDB 快照，会阻塞主线程；")]),e._v(" "),a("li",[a("code",[e._v("bgsave")]),e._v("：这也是 Redis 服务端默认的 RDB 快照机制，会 fork 一个子进程进行 RDB 快照，不会阻塞主线程")])]),e._v(" "),a("p",[e._v("可以看到，最快的情况下，RDB 快照也是 1 分钟执行一次，如果数据更新频繁，RDB 快照的滞后还是很明显的，所以，目前 Redis 采用的是 RDB + AOF 混合持久化机制，既充分利用了 RDB 快照恢复快，又充分利用了 AOF 日志数据丢失率低（至多 1 秒）")]),e._v(" "),a("h2",{attrs:{id:"redis-4-0混合持久化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-4-0混合持久化"}},[e._v("#")]),e._v(" Redis 4.0混合持久化")]),e._v(" "),a("p",[e._v("重启redis恢复数据集时，很少会使用rdb来恢复内存状态，因为会丢失大量数据。通常会使用aof日志恢复数据，但是重放aof日志性能相对rdb来说要慢很多，这样在redis实例很大的情况下，启动需要花费很长时间。Redis4.0为了解决这个问题，带来了新的持久化选项——混合持久化。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("aof-use-rdb-preamble yes\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("混合持久化aof文件结构：\n如果开启了混合持久化，aof在重写时，不再是单纯将内存数据转换为RESP命令写入aof文件，而是将重写这一刻之前的内存做rdb快照处理，并且将rdb快照内容和增量的aof修改内存数据的命令存在一起，都写入新的aof文件（这里的 AOF 日志不再是全量日志，而是两次 RDB 快照期间发生的增量 AOF 日志，通常这部分 AOF 日志很小），新的aof文件一开始不叫appendonly.aof，等到重写完成后，新的aof文件才会进行改名，新的的覆盖原有的aof文件，完成新旧两个aof文件的替换\n于是在redis重启的时候，可以先加载rdb文件，然后再重放增量的aof日志就可以完全替代之前的aof全量文件重放，因此重启效率大幅得到提高。")])])}),[],!1,null,null,null);s.default=r.exports}}]);