(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{449:function(s,n,a){"use strict";a.r(n);var t=a(33),e=Object(t.a)({},(function(){var s=this,n=s.$createElement,a=s._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"负载均衡策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载均衡策略"}},[s._v("#")]),s._v(" 负载均衡策略")]),s._v(" "),a("ul",[a("li",[a("ol",[a("li",[s._v("轮询 (默认)：\n每一个来自网络中的请求，轮流分配给内部的服务器，从 1 到 N 然后重新开始。此种负载均衡算法适合服务器组内部的服务器都具有相同的配置并且平均服务请求 相对均衡的情况。")])])]),s._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[s._v("加权轮询（weight）：根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是\n6，则服务器 A、B、C 将分别接受到 10%、30%、60% 的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。")])])]),s._v(" "),a("li",[a("p",[s._v("3.ip-hash（ip_hash）：\n我们都知道，每个请求的客户端都有相应的 ip 地址，该均衡策略中，nginx 将会根据相应的 hash 函数，对每个请求的 ip 作为关键字，得到的 hash 值将会决定将请求分发给相应 Server 进行处理。")])]),s._v(" "),a("li",[a("ol",{attrs:{start:"4"}},[a("li",[s._v("最少连接数（least_conn）：\n最少连接，也就是说 nginx 会判断后端集群服务器中哪个 Server 当前的 Active Connection 数是最少的，那么对于每个新进来的请求，nginx 将该其分发给对应的 Server。")])])])]),s._v(" "),a("h3",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[s._v("#")]),s._v(" 语法")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("语法: upstream name { ... } \n默认值: —\n上下文: http\n\nupstream 指令当中包含server指令\n语法: server address [parameters]; \n上下文: upstream\n\n例子:\nupstream backend {\n    server backend1.example.com:8081 weight=4 max_fails=2 fail_timeout=30s; \n    server backend2.example.com:8080 weight=1;\n}\nserver { \n    location / {\n        proxy_pass http://backend; \n    }\n}\n\n参数说明:\nweight=number 设定服务器的权重，默认是1，权重越大被访问机会越大，可以根据机器的配置情况来配置。\n\nmax_fails=number 设定Nginx与服务器通信的尝试失败的次数。在fail_timeout参数定义的时间段内，如果失败的次数达到此值，Nginx就认为服务器不 可用。在下一个fail_timeout时间段，服务器不会再被尝试。 失败的尝试次数默认是1。\n\n默认配置时，http_404状态不被认为是失败的尝试。 可以通过指令proxy_next_upstream 和memcached_next_upstream来配置什么是失败的尝试。\n\nfail_timeout=time\n统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到指定的尝试次数，服务器就被认为不可用。默认情况下，该超时时间是10秒。 \n\nbackup\n标记为备用服务器。当主服务器不可用以后，请求会被传给这些服务器，配置这个指令可以实现故障转移。\n\ndown 标记服务器永久不可用，可以跟ip_hash指令一起使用。\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br")])]),a("blockquote",[a("p",[s._v("即便未设置诸多参数，默认情况下，当其中某个 server 挂掉之后，nginx 还是会把请求分发到正常的 server 中去。但一般建议我们手动去设置")])]),s._v(" "),a("h3",{attrs:{id:"proxy-next-upstream-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy-next-upstream-指令"}},[s._v("#")]),s._v(" proxy_next_upstream 指令")]),s._v(" "),a("ul",[a("li",[s._v("在 nginx 的配置文件中， proxy_next_upstream 项定义了什么情况下进行重试")])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("语法: proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...; \n默认值: proxy_next_upstream error timeout;\n上下文: http, server, location\n\n其中:\nerror 表示和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误。 \n\ntimeout 表示和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时。 \n\ninvalid_header 表示后端服务器返回空响应或者非法响应头\n\nhttp_500 表示后端服务器返回的响应状态码为500\n\nnon_idempotent 通常，如果请求已发送到上游服务器，则具有非等幂方法（POST、LOCK、PATCH）的请求不会传递到下一个服务器；启用此选项可显式允许重试此类请求；\n\noff 表示停止将请求发送给下一台后端服务器\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br")])]),a("blockquote",[a("p",[s._v("注意下 non_idempotent 参数，proxy_next_upstream 配置默认转发 get 请求，但对于 post 等请求并无效果，建议配置这一项。")])]),s._v(" "),a("h3",{attrs:{id:"相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关"}},[s._v("#")]),s._v(" 相关")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("proxy_next_upstream_tries number:设置重试次数，默认0表示不限制，注意此重试次数指的是所有请求次数(包括第一次和之后的重试次数之和)。 \n\nproxy_next_upstream_timeout time: 设置重试最大超时时间，默认0表示不限制。\n即在 proxy_next_upstream_timeout 时间内允许 proxy_next_upstream_tries 次重试。如果超过了其中一个设置，则 Nginx 也会结束重试并返回客户 端响应(可能是错误码)。\n\nproxy_send_timeout 后端服务器数据回传时间(代理发送超时时间)\n\nproxy_read_timeout  连接成功后，后端服务器响应时间(代理接收超时时间) \n\nproxy_connect_timeout nginx连接后端的超时时间，一般不超过75s\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])])])}),[],!1,null,null,null);n.default=e.exports}}]);