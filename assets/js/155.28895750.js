(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{569:function(e,a,v){"use strict";v.r(a);var _=v(33),s=Object(_.a)({},(function(){var e=this,a=e.$createElement,v=e._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[e._v("#")]),e._v(" 定义")]),e._v(" "),v("p",[e._v("索引是存储引擎用于快速找到记录的一种数据结构。")]),e._v(" "),v("h2",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),v("ul",[v("li",[e._v("提高查询速度：减少服务器需要扫描的数据量")]),e._v(" "),v("li",[e._v("提高排序速度：帮助服务器避免临时排序和临时表")]),e._v(" "),v("li",[e._v("提高分组统计速度：随机I/O变为顺序I/O，有利于分组统计")])]),e._v(" "),v("h2",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),v("ul",[v("li",[e._v("创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加")]),e._v(" "),v("li",[e._v("索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大")]),e._v(" "),v("li",[e._v("当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度")])]),e._v(" "),v("h2",{attrs:{id:"适合创建索引的字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适合创建索引的字段"}},[e._v("#")]),e._v(" 适合创建索引的字段")]),e._v(" "),v("ul",[v("li",[e._v("表的主键、外键必须有索引")]),e._v(" "),v("li",[e._v("数据量超过300的表应该有索引")]),e._v(" "),v("li",[e._v("经常与其他表进行连接的表，在连接字段上应该建立索引")]),e._v(" "),v("li",[e._v("经常出现在Where子句中的字段，特别是大表的字段，应该建立索引")]),e._v(" "),v("li",[e._v("索引应该建在选择性高的字段上")]),e._v(" "),v("li",[e._v("索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引")]),e._v(" "),v("li",[e._v("复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替")]),e._v(" "),v("li",[e._v("频繁进行数据操作的表，不要建立太多的索引")]),e._v(" "),v("li",[e._v("删除无用的索引，避免对执行计划造成负面影响")]),e._v(" "),v("li",[e._v("在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的")]),e._v(" "),v("li",[e._v("在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间")])]),e._v(" "),v("h2",{attrs:{id:"不适合创建索引的字段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不适合创建索引的字段"}},[e._v("#")]),e._v(" 不适合创建索引的字段")]),e._v(" "),v("ul",[v("li",[e._v("对于那些在查询中很少使用或者参考的列不应该创建索引")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求")])]),e._v(" "),v("ul",[v("li",[e._v("对于那些只有很少数据值的列也不应该增加索引")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度")])]),e._v(" "),v("ul",[v("li",[e._v("对于那些定义为text, image和bit数据类型的列不应该增加索引")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：这些列的数据量要么相当大，要么取值很少")])]),e._v(" "),v("ul",[v("li",[e._v("当修改性能远远大于检索性能时，不应该创建索")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引")])]),e._v(" "),v("h2",{attrs:{id:"创建索引注意事项"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建索引注意事项"}},[e._v("#")]),e._v(" 创建索引注意事项")]),e._v(" "),v("ul",[v("li",[e._v("索引不会包含NULL值的列")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为NULL")])]),e._v(" "),v("ul",[v("li",[e._v("使用短索引")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作")])]),e._v(" "),v("ul",[v("li",[e._v("索引排序")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引")])]),e._v(" "),v("ul",[v("li",[e._v("like语句操作")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%a%” 不会使用索引而like “aaa%”可以使用索引")])]),e._v(" "),v("ul",[v("li",[e._v("不要在列上进行计算")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：select from users where YEAR(adddate)<2007\n将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成\nselect from users where adddate<‘2007-01-01’")])]),e._v(" "),v("ul",[v("li",[e._v("尽量不使用NOT IN和<>操作")])]),e._v(" "),v("blockquote",[v("p",[v("code",[e._v("原因")]),e._v("：NOT IN和<>操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替")])]),e._v(" "),v("hr"),e._v(" "),v("hr"),e._v(" "),v("hr"),e._v(" "),v("hr"),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"什么是索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是索引"}},[e._v("#")]),e._v(" 什么是索引")]),e._v(" "),v("ul",[v("li",[e._v("索引是对数据库表中一列或者多列的值进行排序的"),v("code",[e._v("一种结构")])]),e._v(" "),v("li",[e._v("索引用于快速找出在某个列中有一"),v("code",[e._v("特定值")]),e._v("的行")]),e._v(" "),v("li",[e._v("不使用索引，"),v("code",[e._v("MySQL")]),e._v("必须从第一条记录开始读完"),v("code",[e._v("整个表")]),e._v("，直到找出相关的行")]),e._v(" "),v("li",[v("code",[e._v("表越大")]),e._v("，查询数据所花费的时间"),v("code",[e._v("越多")])]),e._v(" "),v("li",[e._v("如果表中查询的列有一个"),v("code",[e._v("索引")]),e._v("，"),v("code",[e._v("MySQL")]),e._v("能"),v("code",[e._v("快速到达")]),e._v("一个位置去搜索数据文件，而不必"),v("code",[e._v("查看所有数据")]),e._v("。")])]),e._v(" "),v("h2",{attrs:{id:"索引的含义和特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的含义和特点"}},[e._v("#")]),e._v(" 索引的含义和特点")]),e._v(" "),v("ul",[v("li",[e._v("索引是一个单独的、存储在磁盘上的"),v("code",[e._v("数据库结构")]),e._v("，它们包含着对数据表里所有记录的"),v("code",[e._v("引用指针")]),e._v("。")]),e._v(" "),v("li",[e._v("使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是"),v("code",[e._v("提高查询操作速度")]),e._v("的"),v("code",[e._v("最佳途径")]),e._v("。")])]),e._v(" "),v("h3",{attrs:{id:"例如"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#例如"}},[e._v("#")]),e._v(" 例如:")]),e._v(" "),v("blockquote",[v("p",[e._v("数据库里面有20000条记录，现在要执行这么一个查询："),v("code",[e._v("SELECT * FROM table where num = 10000")]),e._v("。如果没有索引，必须遍历整个表，直到num等于10000的这一行被找到为止；如果在num列上创建索引，MySQL不需要任何扫描，直接在索引中找10000，就可以得知值这一行的位置。可见，索引的建立可以提高数据库的查询速度。")])]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("索引是在存储引擎中实现的，因此，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持所有索引类型。所有存储引擎支持"),v("code",[e._v("每个表至少16个索引")]),e._v("，"),v("code",[e._v("总索引长度至少为256字节")]),e._v("。大多数存储引擎有更高的额限制，"),v("code",[e._v("MySQL")]),e._v("中索引的存储类型有两种："),v("code",[e._v("BTREE")]),e._v("和"),v("code",[e._v("HASH")]),e._v("，具体和表的存储引擎相关；MyISAM和InnoDB存储引擎只支持BTREE索引，MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。")]),e._v(" "),v("h3",{attrs:{id:"索引的优点主要有"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的优点主要有"}},[e._v("#")]),e._v(" 索引的优点主要有：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("1、通过创建"),v("code",[e._v("唯一索引")]),e._v("，可以保证数据库表中每一行数据的"),v("code",[e._v("唯一性")])])]),e._v(" "),v("li",[v("p",[e._v("2、"),v("code",[e._v("可以大大加快数据的查询速度，减少服务器需要扫描的数据量,这也是创建索引最主要的原因")])])]),e._v(" "),v("li",[v("p",[e._v("3、在实现数据的参考完整性方面，可以加速表和表之间的连接")])]),e._v(" "),v("li",[v("p",[e._v("4、在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间")])])]),e._v(" "),v("h3",{attrs:{id:"增加索引不利的方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#增加索引不利的方面"}},[e._v("#")]),e._v(" 增加索引不利的方面：")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("1、"),v("strong",[e._v("创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加")])])]),e._v(" "),v("li",[v("p",[e._v("2、"),v("strong",[e._v("索引需要占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸；如果要建立聚簇索引，那么需要的空间就会更大")])])]),e._v(" "),v("li",[v("p",[e._v("3、"),v("strong",[e._v("当对表中数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度")])])])]),e._v(" "),v("h2",{attrs:{id:"索引的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的分类"}},[e._v("#")]),e._v(" 索引的分类")]),e._v(" "),v("p",[e._v("MySQL的索引可以分为以下几类：")]),e._v(" "),v("h3",{attrs:{id:"_1、普通索引和唯一索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、普通索引和唯一索引"}},[e._v("#")]),e._v(" 1、普通索引和唯一索引")]),e._v(" "),v("p",[e._v("（1）"),v("strong",[e._v("普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值")])]),e._v(" "),v("p",[e._v("1、 直接创建索引")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("create index index_name on table(column(length));\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("常规创建")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("create index index_name on user(name);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("针对字符串的前几个字符进行创建索引，节省空间，减少比较时间、解决排序问题")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("create index index_name on user(name(5));\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("2、修改表结构的方式新增索引")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alter table table_name add index index_name(column(length));\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("常规创建")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alter table user add index index_name(name);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("对字符串的前几个字符进行创建索引")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alter table user add index index_name(name(10));\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("3、创建表的时候同时创建索引")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CREATE TABLE `table` (\n    `id` int(11) NOT NULL AUTO_INCREMENT ,\n    `name` char(20) CHARACTER NOT NULL ,\n    PRIMARY KEY (`id`),\n    INDEX index_name (name(length))\n);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br")])]),v("p",[e._v("4、删除索引")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("drop index index_name on table;\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("（2）"),v("strong",[e._v("唯一索引，索引列的值必须唯一，但允许有空值，主键索引是一种特殊的唯一索引，不允许有空值，如果是组合索引，则列值的组合必须唯一")])]),e._v(" "),v("p",[e._v("1、 创建索引")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CREATE UNIQUE INDEX indexName ON mytable(username(length))\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("常规创建")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("create unique index index_name on user(name);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("2、修改表结构")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("ALTER TABLE table_name ADD UNIQUE indexName(column(length))\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("常规创建")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alter table user add unique index index_name(name);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("3、创建表的时候直接指定")]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CREATE TABLE `table` (\n    `id` int(11) NOT NULL AUTO_INCREMENT ,\n    `name` char(20) CHARACTER NOT NULL ,\n    PRIMARY KEY (`id`),\n    UNIQUE INDEX index_name (name(length))\n)\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br")])]),v("h3",{attrs:{id:"_2、单列索引和组合索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、单列索引和组合索引"}},[e._v("#")]),e._v(" 2、单列索引和组合索引")]),e._v(" "),v("p",[e._v("（1）"),v("strong",[e._v("单列索引即一个索引只包含单个列，一个表可以有多个单列索引")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("alter table user add index index_name(name);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("p",[e._v("（2）"),v("strong",[e._v("组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用。使用组合索引时遵循最左前缀集合。")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("ALTER TABLE `table` ADD INDEX name_city_age (name,city,age);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("h3",{attrs:{id:"_3、全文索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3、全文索引"}},[e._v("#")]),e._v(" 3、全文索引")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("主要用来查找文本中的关键字，而不是直接与索引中的值相比较。")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的- where语句的参数匹配。")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("fulltext索引配合match against操作使用，而不是一般的where语句加like。它可以在create table，alter table ，create index使用。")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("目前只有char、varchar，text 列上可以创建全文索引。")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用CREATE index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多")])])]),e._v(" "),v("li",[v("p",[e._v("创建表的适合添加全文索引")])])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CREATE TABLE `table` (\n    `id` int(11) NOT NULL AUTO_INCREMENT ,\n    `content` text CHARACTER NULL ,\n    PRIMARY KEY (`id`),\n    FULLTEXT (content)\n);\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br"),v("span",{staticClass:"line-number"},[e._v("5")]),v("br"),v("span",{staticClass:"line-number"},[e._v("6")]),v("br")])]),v("ul",[v("li",[e._v("修改表结构添加全文索引")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("ALTER TABLE article ADD FULLTEXT index_content(content)\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("ul",[v("li",[e._v("直接创建索引")])]),e._v(" "),v("div",{staticClass:"language-mysql line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("CREATE FULLTEXT INDEX index_content ON article(content)\n")])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br")])]),v("h2",{attrs:{id:"索引的设计原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的设计原则"}},[e._v("#")]),e._v(" 索引的设计原则")]),e._v(" "),v("p",[e._v("索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍，高效的索引对于获得良好的性能非常重要，设计索引时，应该考虑一下：")]),e._v(" "),v("p",[v("strong",[e._v("1、索引并非越多越好，一个表中如有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新")])]),e._v(" "),v("p",[v("strong",[e._v("2、避免对经常更新的表设计过多的索引，并且索引中的列尽可能要少，而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段")])]),e._v(" "),v("p",[v("strong",[e._v("3、数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引时间还要短，索引可能不会产生优化效果")])]),e._v(" "),v("p",[v("strong",[e._v("4、在条件表达式中经常用到的不同值较多的列上建立索引，在不同值较少的列上不要建立索引，比如性别字段只有男和女，就没必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度")])]),e._v(" "),v("p",[v("strong",[e._v("5、当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度")])]),e._v(" "),v("p",[v("strong",[e._v("6、在频繁排序或分组（即group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引")])]),e._v(" "),v("h2",{attrs:{id:"适合创建索引的字段-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适合创建索引的字段-2"}},[e._v("#")]),e._v(" 适合创建索引的字段")]),e._v(" "),v("ul",[v("li",[v("p",[v("strong",[e._v("表的主键、外键必须有索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("数据量超过300的表应该有索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("经常与其他表进行连接的表，在连接字段上应该建立索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("经常出现在Where子句中的字段，特别是大表的字段，应该建立索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("索引应该建在选择性高的字段上")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("频繁进行数据操作的表，不要建立太多的索引")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("删除无用的索引，避免对执行计划造成负面影响")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的")])])]),e._v(" "),v("li",[v("p",[v("strong",[e._v("在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间")])])])]),e._v(" "),v("h2",{attrs:{id:"不适合创建索引的字段-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不适合创建索引的字段-2"}},[e._v("#")]),e._v(" 不适合创建索引的字段")]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("对于那些在查询中很少使用或者参考的列不应该创建索引")])])]),e._v(" "),v("blockquote",[v("p",[e._v("原因：既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求")])]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("对于那些只有很少数据值的列也不应该增加索引")])])]),e._v(" "),v("blockquote",[v("p",[e._v("原因：由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度")])]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("对于那些定义为text, image和bit数据类型的列不应该增加索引")])])]),e._v(" "),v("blockquote",[v("p",[e._v("原因：这些列的数据量要么相当大，要么取值很少")])]),e._v(" "),v("ul",[v("li",[v("strong",[e._v("当修改性能远远大于检索性能时，不应该创建索")])])]),e._v(" "),v("blockquote",[v("p",[e._v("原因：修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引")])]),e._v(" "),v("h2",{attrs:{id:"创建索引注意事项-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建索引注意事项-2"}},[e._v("#")]),e._v(" 创建索引注意事项")]),e._v(" "),v("p",[v("strong",[e._v("（1）索引不会包含NULL值的列")])]),e._v(" "),v("p",[e._v("原因：只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为NULL")]),e._v(" "),v("p",[v("strong",[e._v("（2）使用短索引")])]),e._v(" "),v("p",[e._v("原因：对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作")]),e._v(" "),v("p",[v("strong",[e._v("（3）索引排序")])]),e._v(" "),v("p",[e._v("原因：mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引")]),e._v(" "),v("p",[v("strong",[e._v("（4）like语句操作")])]),e._v(" "),v("p",[e._v("原因：一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%a%” 不会使用索引而like “aaa%”可以使用索引")]),e._v(" "),v("p",[v("strong",[e._v("（5）不要在列上进行计算")])]),e._v(" "),v("p",[e._v("原因：select from users where YEAR(adddate)<2007\n将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成\nselect from users where adddate<‘2007-01-01’")]),e._v(" "),v("p",[v("strong",[e._v("（6）尽量不使用NOT IN和<>操作")])]),e._v(" "),v("p",[e._v("原因：NOT IN和<>操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id<>3则可使用id>3 or id<3来代替")]),e._v(" "),v("h2",{attrs:{id:"聚集和非聚集索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#聚集和非聚集索引"}},[e._v("#")]),e._v(" 聚集和非聚集索引")]),e._v(" "),v("p",[e._v("简单概括：")]),e._v(" "),v("ul",[v("li",[e._v("聚集索引就是以主键创建的索引")]),e._v(" "),v("li",[e._v("非聚集索引就是以非主键创建的索引")])]),e._v(" "),v("p",[e._v("区别：")]),e._v(" "),v("ul",[v("li",[e._v("聚集索引在叶子节点存储的是表中的数据")]),e._v(" "),v("li",[e._v("非聚集索引在叶子节点存储的是主键和索引列")]),e._v(" "),v("li",[e._v("使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。(拿到主键再查找这个过程叫做回表)")])]),e._v(" "),v("blockquote",[v("p",[e._v("非聚集索引也叫做二级索引，不用纠结那么多名词，将其等价就行了")])]),e._v(" "),v("p",[e._v("非聚集索引在建立的时候也未必是单列的，可以多个列来创建索引。")]),e._v(" "),v("ul",[v("li",[e._v("此时就涉及到了哪个列会走索引，哪个列不走索引的问题了(最左匹配原则--\x3e后面有说)")]),e._v(" "),v("li",[e._v("创建多个单列(非聚集)索引的时候，会生成多个索引树(所以过多创建索引会占用磁盘空间)")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20201012205221.jpeg",alt:""}})]),e._v(" "),v("p",[e._v("在创建多列索引中也涉及到了一种特殊的索引--\x3e"),v("strong",[e._v("覆盖索引")])]),e._v(" "),v("ul",[v("li",[e._v("我们前面知道了，如果不是聚集索引，叶子节点存储的是主键+列值")]),e._v(" "),v("li",[e._v("最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢")]),e._v(" "),v("li",[e._v("覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！")])]),e._v(" "),v("p",[e._v("比如说：")]),e._v(" "),v("ul",[v("li",[e._v("现在我创建了索引("),v("code",[e._v("username,age")]),e._v(")，在查询数据的时候："),v("code",[e._v("select username , age from user where username = 'Java3y' and age = 20")]),e._v("。")]),e._v(" "),v("li",[e._v("很明显地知道，我们上边的查询是走索引的，并且，要查询出的列在叶子节点都存在！所以，就不用回表了~")]),e._v(" "),v("li",[e._v("所以，能使用覆盖索引就尽量使用吧~")])]),e._v(" "),v("h2",{attrs:{id:"索引最左匹配原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引最左匹配原则"}},[e._v("#")]),e._v(" 索引最左匹配原则")]),e._v(" "),v("p",[e._v("最左匹配原则：")]),e._v(" "),v("ul",[v("li",[e._v("索引可以简单如一个列("),v("code",[e._v("a")]),e._v(")，也可以复杂如多个列("),v("code",[e._v("a, b, c, d")]),e._v(")，即联合索引。")]),e._v(" "),v("li",[e._v("如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找"),v("code",[e._v("key")]),e._v("是否存在（"),v("code",[e._v("相等")]),e._v("），遇到范围查询("),v("code",[e._v(">、<、between、like")]),e._v("左匹配)等就不能进一步匹配了，后续退化为线性查找。")]),e._v(" "),v("li",[e._v("因此，列的排列顺序决定了可命中索引的列数。")])]),e._v(" "),v("p",[e._v("例子：")]),e._v(" "),v("ul",[v("li",[e._v("如有索引("),v("code",[e._v("a, b, c, d")]),e._v(")，查询条件"),v("code",[e._v("a = 1 and b = 2 and c > 3 and d = 4")]),e._v("，则会在每个节点依次命中"),v("code",[e._v("a、b、c")]),e._v("，无法命中"),v("code",[e._v("d")]),e._v("。("),v("code",[e._v("c已经是范围查询了，d肯定是排不了序了")]),e._v(")\n为什么能命中c？")])]),e._v(" "),v("p",[e._v("举个简单例子："),v("code",[e._v("select * from user where age >30")]),e._v("; 如果在age列创建索引，那你说会走索引吗？")]),e._v(" "),v("h2",{attrs:{id:"、in自动优化顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#、in自动优化顺序"}},[e._v("#")]),e._v(" =、in自动优化顺序")]),e._v(" "),v("p",[e._v("不需要考虑"),v("code",[e._v("=、in")]),e._v("等的顺序，"),v("code",[e._v("mysql")]),e._v("会自动优化这些条件的顺序，以匹配尽可能多的索引列。")]),e._v(" "),v("p",[e._v("例子：")]),e._v(" "),v("p",[e._v("如有索引("),v("code",[e._v("a, b, c, d")]),e._v(")，查询条件"),v("code",[e._v("c > 3 and b = 2 and a = 1 and d < 4")]),e._v("与"),v("code",[e._v("a = 1 and c > 3 and b = 2 and d < 4")]),e._v("等顺序都是可以的，MySQL会自动优化为"),v("code",[e._v("a = 1 and b = 2 and c > 3 and d < 4")]),e._v("，依次命中"),v("code",[e._v("a、b、c")]),e._v("。")]),e._v(" "),v("h2",{attrs:{id:"索引总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引总结"}},[e._v("#")]),e._v(" 索引总结")]),e._v(" "),v("blockquote",[v("p",[e._v("索引在数据库中是一个非常重要的知识点！上面谈的其实就是索引最基本的东西，要创建出好的索引要顾及到很多的方面")])]),e._v(" "),v("ul",[v("li",[e._v("1，最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（"),v("code",[e._v(">,<,BETWEEN,LIKE")]),e._v("）就停止匹配。")]),e._v(" "),v("li",[e._v("3，尽量选择区分度高的列作为索引，区分度的公式是 "),v("code",[e._v("COUNT(DISTINCT col) / COUNT(*)")]),e._v("。表示字段不重复的比率，比率越大我们扫描的记录数就越少。")]),e._v(" "),v("li",[e._v("4，索引列不能参与计算，尽量保持列“干净”。比如，"),v("code",[e._v("FROM_UNIXTIME(create_time) = '2016-06-06'")]),e._v(" 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： "),v("code",[e._v("create_time = UNIX_TIMESTAMP('2016-06-06')")]),e._v("。")]),e._v(" "),v("li",[e._v("5，尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（"),v("code",[e._v("a,b")]),e._v("）的索引，那么只需要修改原来的索引即可。")]),e._v(" "),v("li",[e._v("6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，"),v("s",[e._v("MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引")]),e._v("(经指正，在MySQL5.0以后的版本中，有“合并索引”的策略，翻看了《高性能MySQL 第三版》，书作者认为：还是应该建立起比较好的索引，而不应该依赖于“合并索引”这么一个策略)。\n"),v("ul",[v("li",[e._v("“合并索引”策略简单来讲，就是使用多个单列索引，然后将这些结果用“union或者and”来合并起来")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);