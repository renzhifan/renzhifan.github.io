(window.webpackJsonp=window.webpackJsonp||[]).push([[196],{611:function(t,a,n){"use strict";n.r(a);var e=n(33),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"ack机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ack机制"}},[t._v("#")]),t._v(" ACK机制")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/upic_img/master/uPic/2022/05/16/11-06-50-vUVF9w-bXUQnT.jpg",alt:"11-06-50-vUVF9w-bXUQnT"}})]),t._v(" "),n("p",[t._v("所谓的ACK确认机制")]),t._v(" "),n("p",[t._v("自动ACK：消费者接收到消息后自动发送ACK给RabbitMQ。")]),t._v(" "),n("p",[t._v("手动ACK：我们手动控制消费者接收到并成功消息后发送ACK给RabbitMQ。")]),t._v(" "),n("p",[t._v("你可以看上图：如果使用自动ACK，当消息者将消息从channel中取出后，RabbitMQ随即将消息给删除。接着不幸的是，消费者没来得及处理消息就挂了。那也就意味着消息其实丢失了。")]),t._v(" "),n("p",[t._v("你可能会说：会不会存在重复消费的情况呢？这其实就不是MQ的问题了。你完全可以在你代码的逻辑层面上进行诸如去重、插入前先检查是否已存在等逻辑规避重复消费问题。")])])}),[],!1,null,null,null);a.default=r.exports}}]);