(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{457:function(t,e,s){"use strict";s.r(e);var v=s(33),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"为啥要用websocket"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为啥要用websocket"}},[t._v("#")]),t._v(" 为啥要用websocket")]),t._v(" "),s("blockquote",[s("p",[t._v("WebSocket 本来是作为 HTML5 的一部分，而现在却变成了一个独立的协议，它是 Web 客户端与服务器之间实现全双工通信的标准。既然是全双工，就意味着不是之前那种只能从客户端向服务器发起请求的单向通信，服务端在必要的时候也可以推送信息到客户端，而不是被动接收客户端请求再返回响应")])]),t._v(" "),s("h2",{attrs:{id:"websocket优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket优势"}},[t._v("#")]),t._v(" websocket优势")]),t._v(" "),s("blockquote",[s("p",[t._v("一旦客户端与服务器之间建立起了基于 WebSocket 协议的通信连接，之后所有的通信都依靠这个协议进行，双方可以互相发送 JSON、XML、HTML、图片等任意格式的数据。由于 WebSocket 是基于 HTTP 协议的，所以连接的发起方还是客户端，而一旦建立起 WebSocket 连接，不论是服务器还是客户端，都可以直接向对方发送报文")])]),t._v(" "),s("h2",{attrs:{id:"websocket握手步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#websocket握手步骤"}},[t._v("#")]),t._v(" websocket握手步骤")]),t._v(" "),s("ul",[s("li",[t._v("为了实现 WebSocket 的通信，在 HTTP 连接建立之后，还需要完成一次「握手」的步骤：")])]),t._v(" "),s("h3",{attrs:{id:"请求阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#请求阶段"}},[t._v("#")]),t._v(" 请求阶段")]),t._v(" "),s("p",[s("code",[t._v("WebSocket")]),t._v(" 复用了 "),s("code",[t._v("HTTP")]),t._v(" 的握手通道，要建立 "),s("code",[t._v("WebSocket")]),t._v(" 通信，需要在连接发起方的 "),s("code",[t._v("HTTP")]),t._v(" 请求报文中通过 "),s("code",[t._v("Upgrade")]),t._v(" 字段告知服务器通信协议升级到 "),s("code",[t._v("Websocket")]),t._v("，然后通过 "),s("code",[t._v("Sec-WebSocket-*")]),t._v(" 扩展字段提供 "),s("code",[t._v("WebSocket")]),t._v(" 的协议、版本、键值等信息：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20210123214618.jpeg",alt:""}})]),t._v(" "),s("h3",{attrs:{id:"响应阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#响应阶段"}},[t._v("#")]),t._v(" 响应阶段")]),t._v(" "),s("ul",[s("li",[t._v("对于上述握手请求，服务器会返回 "),s("strong",[t._v("101 Switching Protocols")]),t._v(" 响应表示协议升级成功：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20210123214647.jpeg",alt:""}})]),t._v(" "),s("p",[t._v("响应头中 "),s("strong",[t._v("Sec-WebSocket-Accept")]),t._v(" 字段的值是根据请求头中 "),s("strong",[t._v("Sec-WebSocket-Key")]),t._v(" 的字段值生成的，两者结合起来用于防止恶意连接和意外连接")]),t._v(" "),s("h3",{attrs:{id:"握手成功"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#握手成功"}},[t._v("#")]),t._v(" 握手成功")]),t._v(" "),s("p",[t._v("成功握手确立 "),s("strong",[t._v("WebSocket")]),t._v(" 连接后，后续通信就会使用 "),s("strong",[t._v("WebSocket")]),t._v("数据帧而不是 "),s("strong",[t._v("HTTP")]),t._v(" 数据帧。下面是 "),s("strong",[t._v("WebSocket")]),t._v(" 通信的时序图：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/renzhifan/image/master/img/20210123214719.jpeg",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("WebSocket")]),t._v(" 协议对应的 "),s("strong",[t._v("scheme")]),t._v(" 是 "),s("strong",[t._v("ws")]),t._v("，如果是加密的 "),s("strong",[t._v("WebSocket")]),t._v(" 对应的 "),s("strong",[t._v("scheme")]),t._v(" 是 "),s("strong",[t._v("wss")]),t._v("，域名、端口、路径、参数和 "),s("strong",[t._v("HTTP")]),t._v(" 协议的 "),s("strong",[t._v("URL")]),t._v(" 一样。")])])}),[],!1,null,null,null);e.default=_.exports}}]);